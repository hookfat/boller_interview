一、設計理念
本模擬系統主要用來描述電梯在一棟 10 層樓建築中運作的情況，模擬乘客呼叫、電梯上下客以及移動過程。設計理念在於清晰分離各個角色的責任，使得整個模擬流程簡單易懂，並能針對不同部分進行獨立優化與調試。整體採用了物件導向的設計方法，每個實體（乘客、樓層、電梯、控制器）均封裝了自身的屬性與行為，藉此實現模組化與易維護的架構。

二、採用的設計方法
物件導向設計 (OOP)：

透過建立多個類別（Passenger、Floor、Elevator、Controller），將不同的行為與資料封裝在各自的物件中。
每個類別都有明確的責任，例如 Elevator 負責上下客、移動與更新方向，而 Controller 則負責整個模擬流程的調度。
封裝 (Encapsulation)：

將上下客、移動、方向更新等方法定義在各自的類別中，避免各功能間的耦合，提高程式可讀性與可維護性。
如 Elevator 內部的 stop()、board() 與 updateDirection() 都只處理與電梯本身有關的邏輯。
分離關注點 (Separation of Concerns)：

控制器 (Controller) 將模擬流程（如乘客生成、上下客、移動）與各個實體的細節邏輯分開管理。
樓層 (Floor) 僅負責管理等待乘客的資料，乘客 (Passenger) 僅儲存基本資訊，而調度與流程則由 Controller 統一處理。
狀態管理：

為每部電梯設計了一個 serviced 屬性，用以記錄當前單位時間內是否已經完成上客或下客服務。
這確保了在同一時間單位內，若電梯已進行過上下客操作，就不再移動，模擬真實情況中「服務花費一個時間單位」的情形。
三、各個方法與功能解釋
Passenger 類別

設計目的： 儲存乘客的基本資訊，如乘客編號、起始樓層、目的樓層與產生時間。
核心方法：
constructor(id, startFloor, destFloor, arrivalTime)：初始化乘客物件，並記錄基本屬性。
Floor 類別

設計目的： 管理某一樓層上的等待乘客。
核心方法：
addWaitingPassenger(passenger)：將新產生的乘客加入等待隊列。
getPassengersForElevator(availableSpace)：根據電梯可用空間取出一定數量的乘客，並從等待隊列中移除。
hasWaitingPassengers()：檢查該樓層是否還有乘客等待。
Elevator 類別

設計目的： 模擬電梯的行為，包括上下客、移動以及方向更新，並利用 targetFloors 儲存需要停靠的樓層。
核心方法：
constructor(id)：初始化電梯，設定初始樓層、狀態（如 idle）以及容量限制。
move()：根據目前的方向（up/down）移動一層；這裡每次移動代表耗費一個單位時間。
stop()：當電梯到達某樓層時，檢查是否有乘客的目的地正好是當前樓層，如果有則讓乘客下車，並從 targetFloors 中移除。
board(passengers)：將該樓層等待的乘客上車（如果有足夠空位），同時將這些乘客的目的樓層加入 targetFloors。
updateDirection()：依據目前 targetFloors 中的目標樓層，計算與當前樓層的距離，並更新方向為 up 或 down；若無目標則設為 idle。
新增屬性 serviced： 用於標記該單位時間內是否已執行上下客服務，若有服務則在本時間單位內不再移動電梯。
Controller 類別

設計目的： 負責整個模擬流程的調度，包括乘客生成、電梯的上/下客調度、電梯移動與統計已完成乘客數。
核心方法：
generatePassenger()：每單位時間隨機產生一位乘客，並將乘客加入對應樓層的等待隊列；同時，直接將該乘客的起始樓層加入所有電梯的 targetFloors 中，確保電梯會前往該樓層接人。
assignElevators()：檢查每部電梯當前所在樓層，如果該樓層有等待乘客且電梯有空位，就呼叫 board() 方法讓乘客上車。
simulate()：模擬主循環，每個單位時間依序執行乘客生成、電梯下客、上客、方向更新與移動。
在此流程中，首先重置每部電梯的 serviced 狀態；
執行下客與上客後，如果該電梯未執行過服務則執行移動，否則顯示暫停移動的 log。
另外，透過統計等待乘客與車內乘客來計算已完成行程的乘客數，直到總乘客數達到預定上限後結束模擬。
四、總結
本版本透過整合上下客的邏輯，使得在同一個單位時間內，只要電梯完成上客或下客，就視為已經消耗一個時間單位，不會再進行移動。

物件導向設計 讓每個模擬單元（乘客、樓層、電梯、控制器）具有明確的責任與邏輯；
封裝 使得各自的行為（如上下客、移動、更新方向）被獨立管理；
分離關注點 則確保調度邏輯與個別元件行為不混雜，便於後續的優化與調整。
透過這樣的設計，模擬系統既具有清晰的結構，也便於未來針對優化策略做進一步的擴充與調整。